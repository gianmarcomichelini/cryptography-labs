//
// Created by gim on 10/08/25.
//
#include <openssl/rand.h>
#include <openssl/err.h>

#include "utils.h"

#define KEY_LEN 16

int verify(const unsigned char *hmac_key, size_t key_len,
           const unsigned char *message, size_t message_len,
           const unsigned char *expected_digest, size_t expected_digest_len);

int hashing_hmac_verify(void) {
    int rc;

    unsigned char hmac_key[KEY_LEN];
    rc = RAND_bytes(hmac_key, sizeof(hmac_key));
    if (rc != 1)
        handle_md_errors("ERROR: generating the HMAC key", NULL);

    printf("The secret key (generated by RAND_bytes) is: ");
    print_hex_buffer(hmac_key, KEY_LEN);

    const unsigned char message[] = "Simple Message";
    size_t message_len = sizeof(message) - 1;

    // Compute HMAC digest using EVP_DigestSign*
    EVP_PKEY *hkey = EVP_PKEY_new_mac_key(EVP_PKEY_HMAC, NULL, hmac_key, KEY_LEN);
    if (!hkey)
        handle_md_errors("ERROR: creating EVP_PKEY HMAC key", NULL);

    EVP_MD_CTX *hmac_ctx = EVP_MD_CTX_new();
    if (!hmac_ctx) {
        EVP_PKEY_free(hkey);
        handle_md_errors("ERROR: creating EVP_MD_CTX", NULL);
    }

    rc = EVP_DigestSignInit(hmac_ctx, NULL, EVP_sha256(), NULL, hkey);
    if (rc != 1)
        handle_md_errors("ERROR: initializing DigestSignInit", hmac_ctx);

    rc = EVP_DigestSignUpdate(hmac_ctx, message, message_len);
    if (rc != 1)
        handle_md_errors("ERROR: updating DigestSign", hmac_ctx);

    size_t hmac_len = 0;
    rc = EVP_DigestSignFinal(hmac_ctx, NULL, &hmac_len);
    if (rc != 1)
        handle_md_errors("ERROR: getting HMAC length", hmac_ctx);

    unsigned char *hmac_value = OPENSSL_malloc(hmac_len);
    if (!hmac_value)
        handle_md_errors("ERROR: allocating memory for HMAC", hmac_ctx);

    rc = EVP_DigestSignFinal(hmac_ctx, hmac_value, &hmac_len);
    if (rc != 1) {
        OPENSSL_free(hmac_value);
        handle_md_errors("ERROR: finalizing DigestSign", hmac_ctx);
    }

    printf("HMAC digest (SHA256): ");
    print_hex_buffer(hmac_value, hmac_len);

    EVP_MD_CTX_free(hmac_ctx);
    EVP_PKEY_free(hkey);

    // Verify the computed digest matches the expected digest (ourselves)
    rc = verify(hmac_key, KEY_LEN, message, message_len, hmac_value, hmac_len);

    if (rc == 1)
        printf("Verification succeeded: HMAC is valid.\n");
    else
        printf("Verification failed: HMAC is invalid.\n");

    OPENSSL_free(hmac_value);

    return rc == 1 ? EXIT_SUCCESS : EXIT_FAILURE;
}
int verify(const unsigned char *hmac_key, size_t key_len,
           const unsigned char *message, size_t message_len,
           const unsigned char *expected_digest, size_t expected_digest_len) {

    EVP_MD_CTX *hmac_ctx = EVP_MD_CTX_new();
    if (!hmac_ctx)
        handle_md_errors("ERROR: creating EVP_MD_CTX", NULL);

    EVP_PKEY *hkey = EVP_PKEY_new_mac_key(EVP_PKEY_HMAC, NULL, hmac_key, (int) key_len);
    if (!hkey) {
        EVP_MD_CTX_free(hmac_ctx);
        handle_md_errors("ERROR: creating EVP_PKEY HMAC key", NULL);
    }

    // Init for HMAC-SHA256
    if (EVP_DigestSignInit(hmac_ctx, NULL, EVP_sha256(), NULL, hkey) != 1) {
        EVP_PKEY_free(hkey);
        EVP_MD_CTX_free(hmac_ctx);
        handle_md_errors("ERROR: initializing DigestSignInit", NULL);
    }

    // Feed the message
    if (EVP_DigestSignUpdate(hmac_ctx, message, message_len) != 1) {
        EVP_PKEY_free(hkey);
        EVP_MD_CTX_free(hmac_ctx);
        handle_md_errors("ERROR: updating DigestSign", NULL);
    }

    // Get computed HMAC length
    size_t hmac_len = 0;
    if (EVP_DigestSignFinal(hmac_ctx, NULL, &hmac_len) != 1) {
        EVP_PKEY_free(hkey);
        EVP_MD_CTX_free(hmac_ctx);
        handle_md_errors("ERROR: getting HMAC length", NULL);
    }

    unsigned char *computed_digest = OPENSSL_malloc(hmac_len);
    if (!computed_digest) {
        EVP_PKEY_free(hkey);
        EVP_MD_CTX_free(hmac_ctx);
        handle_md_errors("ERROR: allocating memory for computed digest", NULL);
    }

    if (EVP_DigestSignFinal(hmac_ctx, computed_digest, &hmac_len) != 1) {
        OPENSSL_free(computed_digest);
        EVP_PKEY_free(hkey);
        EVP_MD_CTX_free(hmac_ctx);
        handle_md_errors("ERROR: finalizing DigestSign", NULL);
    }

    // Compare digests in constant time
    int result = (hmac_len == expected_digest_len) &&
                 (CRYPTO_memcmp(computed_digest, expected_digest, hmac_len) == 0);

    OPENSSL_free(computed_digest);
    EVP_PKEY_free(hkey);
    EVP_MD_CTX_free(hmac_ctx);

    return result ? 1 : 0;
}