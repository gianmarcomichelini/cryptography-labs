//
// Created by gim on 10/08/25.
//
#include <openssl/err.h>
#include <openssl/rand.h>

#include "utils.h"

#define KEY_LEN 16


int hashing_hmac_compute(void) {
    int rc;

    unsigned char hmac_key[KEY_LEN];
    rc = RAND_bytes(hmac_key, KEY_LEN);
    if (rc != 1)
        handle_md_errors("ERROR: generating the HMAC key", NULL);

    printf("The secret key (generated by RAND_bytes) is: ");
    print_hex_buffer(hmac_key, KEY_LEN);

    // Create EVP_PKEY for HMAC key
    EVP_PKEY *hkey = EVP_PKEY_new_mac_key(EVP_PKEY_HMAC, NULL, hmac_key, KEY_LEN);
    if (!hkey)
        handle_md_errors("ERROR: creating EVP_PKEY HMAC key", NULL);

    // Create context
    EVP_MD_CTX *hmac_ctx = EVP_MD_CTX_new();
    if (!hmac_ctx)
        handle_md_errors("ERROR: creating EVP_MD_CTX", NULL);

    // Initialize signing (HMAC) with SHA256
    rc = EVP_DigestSignInit(hmac_ctx, NULL, EVP_sha256(), NULL, hkey);
    if (rc != 1)
        handle_md_errors("ERROR: initializing DigestSignInit", hmac_ctx);

    const unsigned char message[] = "Simple Message";

    rc = EVP_DigestSignUpdate(hmac_ctx, message, sizeof(message) - 1);
    if (rc != 1)
        handle_md_errors("ERROR: updating DigestSign", hmac_ctx);

    size_t hmac_len = 0;
    // Call once with NULL to get the required length
    rc = EVP_DigestSignFinal(hmac_ctx, NULL, &hmac_len);
    if (rc != 1)
        handle_md_errors("ERROR: getting HMAC length", hmac_ctx);

    unsigned char *hmac_value = OPENSSL_malloc(hmac_len);
    if (!hmac_value)
        handle_md_errors("ERROR: allocating memory for HMAC", hmac_ctx);

    rc = EVP_DigestSignFinal(hmac_ctx, hmac_value, &hmac_len);
    if (rc != 1) {
        OPENSSL_free(hmac_value);
        handle_md_errors("ERROR: finalizing DigestSign", hmac_ctx);
    }

    printf("HMAC digest (SHA256): ");
    print_hex_buffer(hmac_value, hmac_len);

    OPENSSL_free(hmac_value);
    EVP_MD_CTX_free(hmac_ctx);
    EVP_PKEY_free(hkey);

    return EXIT_SUCCESS;
}