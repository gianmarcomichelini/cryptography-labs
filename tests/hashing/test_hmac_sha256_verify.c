//
// Created by gim on 10/08/25.
//
#include <openssl/rand.h>

#include "utils.h"
#include "hashing/hashing_utils.h"

#define KEY_LEN 16

// Generates random key, computes HMAC, then verifies it
int test_hmac_sha256_verify(void) {
    int rc;

    unsigned char hmac_key[KEY_LEN];
    rc = RAND_bytes(hmac_key, sizeof(hmac_key));
    if (rc != 1)
        hashing_handle_md_errors("ERROR: generating the HMAC key", NULL);

    printf("The secret key (generated by RAND_bytes) is: ");
    print_hex_buffer(hmac_key, KEY_LEN);

    const unsigned char message[] = "Simple Message";
    const size_t message_len = sizeof(message) - 1;

    // Compute HMAC digest with the key and message
    unsigned char *hmac_value = NULL;
    size_t hmac_len = 0;

    rc = hashing_hmac_sha256_compute(hmac_key, KEY_LEN, message, message_len, &hmac_value, &hmac_len);
    if (rc != EXIT_SUCCESS) return EXIT_FAILURE;

    printf("HMAC digest (SHA256): ");
    print_hex_buffer(hmac_value, hmac_len);


    // Verify computed HMAC matches expected (itself)
    rc = hashing_hmac_sha256_verify(hmac_key, KEY_LEN, message, message_len, hmac_value, hmac_len);

    if (rc == 1)
        printf("Verification succeeded: HMAC is valid.\n");
    else
        printf("Verification failed: HMAC is invalid.\n");

    OPENSSL_free(hmac_value);

    return rc == 1 ? EXIT_SUCCESS : EXIT_FAILURE;
}